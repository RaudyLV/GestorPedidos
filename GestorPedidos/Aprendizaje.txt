COSAS APRENDIDAS EN ESTE PROYECTO HASTA AHORA: 

1-REPOSITORIOS SE USAN SOLO PARA EXTRACCION DE DATOS, NO PARA MANEJAR LA LOGICA DE NEGOCIO

2-EN LOS SERVICIOS VA TODA LOGICA ORIENTADA A LA CLASE DE CUAL SEA EL SERVICIO, POR EJEMPLO:

EN ProductService DEBE ESTAR TODA LA LOGICA DE POR EJEMPLO, CRUD'S O DEMAS LOGICA DE NEGOCIO
DE LA CLASE PRODUCTS

3-SI SE NECESITAN VALIDACIONES GRANDES O COMPLEJAS, SE CREA UNA NUEVA CARPETA PARA ESTAS VALIDACIONES
CON EL NOMBRE DE CLASE DE LO QUE VAN A VALIDAR (PASA IGUAL PARA ASP.NET, OJO AHI)

4-ES MEJOR INYECTAR LA DEPENDENCIA DE UN SERVICE QUE DE UN REPOSITORY, SI OTRO SERVICE DEPENDE DE ELLA
YA QUE, ASI LAS VALIDACIONES EN SERVICE SE IMPLEMENTAN TAMBIEN EN EL SERVICE QUE DEPENDE DE ESTE SERVICIO
Y SI CAMBIA LA FORMA DE VALIDACION POR EJEMPLO, NO SE PIERDEN LOS DATOS O EL FLUJO DEL PROGRAMA.

5-UNA CLASE ABSTRACTA ES PARA AQUELLA QUE NO TIENE SENTIDO HACER UNA INSTANCIA, SINO QUE SIRVEN
COMO CLASE BASE PARA OTRAS, EJEMPLO: LA DE PAGO QUE IMPLEMENTA UN METODO ABSTRACTO QUE FORZA A 
LAS QUE HEREDEN DE ESTA A IMPLEMENTAR ESTE METODO CON SU PROPIA LOGICA.

6- ES BUENO CREAR INTERFACES PARA DIFERENTES CLASES QUE PERTENECEN A UN MISMO PROPOSITO O ENTIDAD
EJEMPLO LOS BANCOS BHD Y POPULAR QUE AL FINAL SON BANCOS Y SE COMBINAN CON EL PAGO POR TARJETA, CON
LA INTERFAZ NO TIENEN DE ALGUN OTRO METODO DIRECTAMENTE PUDIENDO AFECTAR EL FLUJO SI SE COMETE ALGUN CAMBIO
SINO QUE CON LA INTERFAZ IMPLEMENTA LA FUNCION Y NO LE IMPORTA EL COMO Y YA. 

7- PODEMOS HACER UN INNERJOIN DENTRO DE OTRO INNERJOIN MEDIANTE UNA LISTA QUE TENGA LA CLASE ORIGINAL DE LA QUE 
ESTAMOS UNIENDO.

8. METODOS AUXILIARES VAN AL FINAL

9- UN SERVICE PUEDE HEREDAR DE OTRO SOLO SI REALMENTE COMPARTEN MUCHA LOGICA EN COMUN

10-HACER LAS FUNCIONES PRIVADAS SOLO SI NO SE USAN FUERA DE LA CLASE

11- HACER UN ATRIBUTO DE CLASE TIPO VIRTUAL SI ESE VALOR CAMBIA EN LAS CLASES QUE HEREDAN DE ELLA, EJEMPLO
UN SUELDO DE UN EMPLEADO